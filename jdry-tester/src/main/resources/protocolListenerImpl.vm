#if ($protocol.getNamespace())
package $this.mangle($protocol.getNamespace());
#end
import java.util.function.Function;
import org.apache.logging.log4j.Level;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import org.softauto.core.AsyncResult;
import org.softauto.core.Handler;
import org.softauto.core.Future;
import org.softauto.serializer.CallFuture;


@org.apache.avro.specific.AvroGenerated
public class Listener {

    private static org.apache.logging.log4j.Logger logger = org.apache.logging.log4j.LogManager.getLogger(Listener.class);
    public static long timeOutInMin = 1;
    public Listener(){
          try {
             if( Class.forName("org.softauto.dispatcher.ListenerObserver", false, this.getClass().getClassLoader())!= null){
                // org.softauto.dispatcher.ListenerObserver.getInstance().register("tests.infrastructure.Listener", this);
             }
             logger.debug("successfully register to Observer " );
         }catch (Exception e){
            logger.error("fail register to Observer " ,e );
         }
    }

    public void setTimeOut(long min){
        this.timeOutInMin = min;
    }

#foreach ($e in $protocol.getMessages().entrySet())
#set ($name = $e.getKey())
#set ($message = $e.getValue())
#set ($response = $message.getResponse())

public static class ${this.mangle($name)}{
    private static ${this.mangle($name)} ${this.unCapitalizeFirstLetter(${this.mangle($name)})}= null;
    boolean gotBefore = false;
    static CountDownLatch lock = new CountDownLatch(0);
    static CountDownLatch lockForResult = new CountDownLatch(0);
#if (${this.javaUnbox($response, true)} != "void" )
    ${this.javaUnbox($response, true)} _result;
#end
#foreach ($p in $message.getRequest().getFields())##
    ${this.javaUnbox($p.schema(), false)} ${this.mangle($p.name())} = $this.getDefaultValue($p.schema().getName());
#end



    public static ${this.mangle($name)} waitTo(){
    if(${this.unCapitalizeFirstLetter(${this.mangle($name)})} == null){
            try{
                logger.debug("waiting for ${this.mangle($name)}");
                ${this.unCapitalizeFirstLetter(${this.mangle($name)})} = new ${this.mangle($name)}();
                lock = new CountDownLatch(1);
                 new ListenerServiceImpl("${this.mangle($name)}"){
                        @Override
                        public Object[] ${this.mangle($name)}(##
#foreach ($p in $message.getRequest().getFields())##
${this.javaUnbox($p.schema(), false)} ${this.mangle($p.name())}#if ($foreach.hasNext), #end
#end
){
                        try{
                            logger.debug("done waiting for ${this.mangle($name)}");
                            lock.countDown();
                            return new Object[]{##
#foreach ($p in $message.getRequest().getFields())##
${this.mangle($p.name())}#if($foreach.hasNext),#end##
#end
            };
                        }catch (Exception e){
                                e.printStackTrace();
                        }
                        return new Object[]{};
                    }
                };
                lock.await(timeOutInMin, TimeUnit.MINUTES);
                if(lock.getCount() > 0){
                     logger.error("timeOut for lock ");
                }
            }catch (Exception e){
               logger.error("fail waitTo ",e);
            }
        }
        logger.debug("successfully wait to ${this.mangle($name)}");
        return ${this.unCapitalizeFirstLetter(${this.mangle($name)})};
    }

    public static void waitTo(Handler<AsyncResult<${this.mangle($name)}>> resultHandler){
    if(${this.unCapitalizeFirstLetter(${this.mangle($name)})} == null){
            try{
                logger.debug("waiting for ${this.mangle($name)}");
                ${this.unCapitalizeFirstLetter(${this.mangle($name)})} = new ${this.mangle($name)}();
                lock = new CountDownLatch(1);
                lock.await(timeOutInMin, TimeUnit.MINUTES);
                if(lock.getCount() > 0){
                   logger.error("timeOut for lock ");
                }
                logger.debug("successfully wait to ${this.mangle($name)}");
                resultHandler.handle(Future.handleResult(${this.unCapitalizeFirstLetter(${this.mangle($name)})}));
            }catch (Exception e){
               logger.error("fail waitTo ",e);
               resultHandler.handle(Future.handleError(e));
            }
        }

    }

public static ${this.mangle($name)} waitToResult(){
    if(${this.unCapitalizeFirstLetter(${this.mangle($name)})} == null){
            try{
                logger.debug("waiting for result of ${this.mangle($name)}");
                ${this.unCapitalizeFirstLetter(${this.mangle($name)})} = new ${this.mangle($name)}();
                lockForResult = new CountDownLatch(1);
                 new ListenerServiceImpl(){
                        @Override
                        public Object[] ${this.mangle($name)}(##
#foreach ($p in $message.getRequest().getFields())##
${this.javaUnbox($p.schema(), false)} ${this.mangle($p.name())}#if ($foreach.hasNext), #end
#end
){
                        try{
                            logger.debug("done waiting for ${this.mangle($name)}");
                            lockForResult.countDown();
                            return new Object[]{##
#foreach ($p in $message.getRequest().getFields())##
${this.mangle($p.name())}#if($foreach.hasNext),#end##
#end
            };
                        }catch (Exception e){
                                e.printStackTrace();
                        }
                        return new Object[]{};
                    }
                };
                lockForResult.await(timeOutInMin, TimeUnit.MINUTES);
                if(lock.getCount() > 0){
                     logger.error("timeOut for lock ");
                }
            }catch (Exception e){
               logger.error("fail waitTo ",e);
            }
        }
        logger.debug("successfully wait to ${this.mangle($name)}");
        return ${this.unCapitalizeFirstLetter(${this.mangle($name)})};
    }

    public static void waitToResult(Handler<AsyncResult<${this.mangle($name)}>> resultHandler){
    if(${this.unCapitalizeFirstLetter(${this.mangle($name)})} == null){
            try{
                logger.debug("waiting for result of ${this.mangle($name)}");
                ${this.unCapitalizeFirstLetter(${this.mangle($name)})} = new ${this.mangle($name)}();
                lockForResult = new CountDownLatch(1);
                lockForResult.await(timeOutInMin, TimeUnit.MINUTES);
                if(lock.getCount() > 0){
                   logger.error("timeOut for lock ");
                }
                logger.debug("successfully wait to ${this.mangle($name)}");
                resultHandler.handle(Future.handleResult(${this.unCapitalizeFirstLetter(${this.mangle($name)})}));
            }catch (Exception e){
               logger.error("fail waitTo ",e);
               resultHandler.handle(Future.handleError(e));
            }
        }

    }



#if (${this.javaUnbox($response, true)} != "void" )
    public ${this.javaUnbox($response, true)} get_Result(){
        return _result;
    }

    public ${this.mangle($name)} get_Result(Handler<AsyncResult<$this.javaType($response,false)>> resultHandler){
        try{
            resultHandler.handle(Future.handleResult(_result));
        }catch (Exception e){
          logger.error("fail  get_Result ",e);
          resultHandler.handle(Future.handleError(e));
        }
        logger.debug("successfully get_Result "+ _result);
        return this;
    }

    public ${this.mangle($name)} get_Result(CallFuture<$this.javaType($response,false)> future){
         return this;
    }


    public ${this.unCapitalizeFirstLetter(${this.mangle($name)})} ${this.mangle($name)}_after(${this.javaUnbox($response, true)} result){
        this._result = result;
        lock.countDown();
        logger.debug("successfully lock countDown for result "+ result);
        return this;
    }
#end


#foreach ($p in $message.getRequest().getFields())##
    public ${this.javaUnbox($p.schema(), false)} get${this.capitalizeFirstLetter(${this.mangle($p.name())})}(){
        return ${this.mangle($p.name())};
    }

    public ${this.mangle($name)} get${this.capitalizeFirstLetter(${this.mangle($p.name())})}(Handler<AsyncResult<$this.javaType($p.schema(),false)>> resultHandler){
        resultHandler.handle(Future.handleResult(${this.mangle($p.name())}));
        return this;
    }

    public ${this.mangle($name)} get${this.capitalizeFirstLetter(${this.mangle($p.name())})}(CallFuture<$this.javaType($p.schema(), false)> future){
       future.handleResult(${this.mangle($p.name())});
       return this;
    }

    public ${this.unCapitalizeFirstLetter(${this.mangle($name)})} set${this.capitalizeFirstLetter(${this.mangle($p.name())})}(${this.javaUnbox($p.schema(), false)} ${this.mangle($p.name())}){
        this.${this.mangle($p.name())} = ${this.mangle($p.name())};
        return this;
    }

#end

    public java.lang.Object[] ${this.mangle($name)}(##
#foreach ($p in $message.getRequest().getFields())##
#*      *#${this.javaUnbox($p.schema(), false)} ${this.mangle($p.name())}#if ($foreach.hasNext), #end
#end
    ){
        try {
            logger.debug("got call for ${this.mangle($name)}");
#foreach ($p in $message.getRequest().getFields())##
           this.${this.mangle($p.name())} = ${this.mangle($p.name())};
#end
            if(!gotBefore){
                lock.countDown();
                gotBefore = true;
                logger.debug("successfully lock countDown for ${this.mangle($name)} call  ");
           }else {
              lockForResult.countDown();
              logger.debug("successfully lockForResult countDown for ${this.mangle($name)} call  ");
           }

        }catch (Exception e){
             logger.error("fail  call for ${this.mangle($name)} ",e);
        }
        return new Object[]{##
#foreach ($p in $message.getRequest().getFields())##
${this.mangle($p.name())}#if ($foreach.hasNext), #end##
#end
};
    }



}

#end## (requests)
}## End of protocol interface
