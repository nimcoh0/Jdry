#if ($protocol.getNamespace())
package $this.mangle($protocol.getNamespace());
#end
import java.util.function.Function;
import org.apache.logging.log4j.Level;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import org.softauto.core.AsyncResult;
import org.softauto.core.Handler;
import org.softauto.core.Future;
import org.softauto.serializer.CallFuture;


@org.apache.avro.specific.AvroGenerated
public class Listener {

    private static org.apache.logging.log4j.Logger logger = org.apache.logging.log4j.LogManager.getLogger(Listener.class);
    public static long timeOutInMin = 1;


    public void setTimeOut(long min){
        this.timeOutInMin = min;
    }

#foreach ($e in $protocol.getMessages().entrySet())
#set ($name = $e.getKey())
#set ($message = $e.getValue())
#set ($response = $message.getResponse())

public static class ${this.mangle($name)}{
    private static ${this.mangle($name)} ${this.unCapitalizeFirstLetter(${this.mangle($name)})}= null;
    static boolean seen = false;
    static CountDownLatch lock = new CountDownLatch(0);
    static CountDownLatch lockForResult = new CountDownLatch(0);
#if (${this.javaUnbox($response, true)} != "void" )
    ${this.javaUnbox($response, true)} _result;
#end
#foreach ($p in $message.getRequest().getFields())##
    static ${this.javaUnbox($p.schema(), false)} ${this.mangle($p.name())} = $this.getDefaultValue($p.schema().getName());
#end



    public static ${this.mangle($name)} waitTo(){
    if(${this.unCapitalizeFirstLetter(${this.mangle($name)})} == null){
            try{
                logger.debug("waiting for ${this.mangle($name)}");
                ${this.unCapitalizeFirstLetter(${this.mangle($name)})} = new ${this.mangle($name)}();
                lock = new CountDownLatch(1);
                 new ListenerServiceImpl("${this.mangle($name)}"){
                        @Override
                        public Object[] ${this.mangle($name)}(##
#foreach ($p in $message.getRequest().getFields())##
${this.javaUnbox($p.schema(), false)} ${this.mangle($p.name())}#if ($foreach.hasNext), #end
#end
){
                        try{
                            logger.debug("done waiting for ${this.mangle($name)}");
                            lock.countDown();
                            seen = true;
                            logger.debug("got call for ${this.mangle($name)} seen:"+seen);
#foreach ($p in $message.getRequest().getFields())##
                            ${this.mangle($name)}.${this.mangle($p.name())} = ${this.mangle($name)}.${this.mangle($p.name())} == $this.getDefaultValue($p.schema().getName()) ? ${this.mangle($p.name())} : ${this.mangle($name)}.${this.mangle($p.name())};
#end
                            return new Object[]{##
#foreach ($p in $message.getRequest().getFields())##
${this.mangle($name)}.${this.mangle($p.name())}#if($foreach.hasNext),#end##
#end
            };
                        }catch (Exception e){
                                 logger.error("fail waitTo ",e);
                        }
                        return new Object[]{};
                    }
                };
                lock.await(timeOutInMin, TimeUnit.MINUTES);
                if(lock.getCount() > 0){
                     logger.error("timeOut for lock ");
                }
            }catch (Exception e){
               logger.error("fail waitTo ",e);
            }
        }
        logger.debug("successfully wait to ${this.mangle($name)}");
        return ${this.unCapitalizeFirstLetter(${this.mangle($name)})};
    }

    public static void waitTo(Handler<AsyncResult<${this.mangle($name)}>> resultHandler){
    if(${this.unCapitalizeFirstLetter(${this.mangle($name)})} == null){
            try{
                logger.debug("waiting for ${this.mangle($name)}");
                ${this.unCapitalizeFirstLetter(${this.mangle($name)})} = new ${this.mangle($name)}();
                lock = new CountDownLatch(1);
                lock.await(timeOutInMin, TimeUnit.MINUTES);
                new ListenerServiceImpl("${this.mangle($name)}"){
                     @Override
                     public Object[] ${this.mangle($name)}(##
#foreach ($p in $message.getRequest().getFields())##
                        ${this.javaUnbox($p.schema(), false)} ${this.mangle($p.name())}#if ($foreach.hasNext), #end
#end
){
                    try{
                        logger.debug("done waiting for ${this.mangle($name)}");
                        lock.countDown();
                        seen = true;
                        logger.debug("got call for ${this.mangle($name)} seen:"+seen);
#foreach ($p in $message.getRequest().getFields())##
                         ${this.mangle($name)}.${this.mangle($p.name())} = ${this.mangle($name)}.${this.mangle($p.name())} == $this.getDefaultValue($p.schema().getName()) ? ${this.mangle($p.name())} : ${this.mangle($name)}.${this.mangle($p.name())};
#end
                         return new Object[]{##
#foreach ($p in $message.getRequest().getFields())##
${this.mangle($name)}.${this.mangle($p.name())}#if($foreach.hasNext),#end##
#end
                            };
                         }catch (Exception e){
                               logger.error("fail waitTo ",e);
                         }
                         return new Object[]{};
                    }
            };
                lock.await(timeOutInMin, TimeUnit.MINUTES);
                if(lock.getCount() > 0){
                     logger.error("timeOut for lock ");
                }
                logger.debug("successfully wait to ${this.mangle($name)}");
                resultHandler.handle(Future.handleResult(${this.unCapitalizeFirstLetter(${this.mangle($name)})}));
            }catch (Exception e){
               logger.error("fail waitTo ",e);
               resultHandler.handle(Future.handleError(e));
            }
        }

    }

    public static ${this.mangle($name)} waitToResult(){
    if(${this.unCapitalizeFirstLetter(${this.mangle($name)})} == null){
            try{
                logger.debug("waiting for result of ${this.mangle($name)}");
                ${this.unCapitalizeFirstLetter(${this.mangle($name)})} = new ${this.mangle($name)}();
                lockForResult = new CountDownLatch(1);
                 new ListenerServiceImpl(){
                        @Override
                        public Object[] ${this.mangle($name)}(##
#foreach ($p in $message.getRequest().getFields())##
${this.javaUnbox($p.schema(), false)} ${this.mangle($p.name())}#if ($foreach.hasNext), #end
#end
){
                        try{
                            logger.debug("done waiting for ${this.mangle($name)}");
                            if(seen){
                            lockForResult.countDown();
#foreach ($p in $message.getRequest().getFields())##
                            ${this.mangle($name)}.${this.mangle($p.name())} = ${this.mangle($name)}.${this.mangle($p.name())} == $this.getDefaultValue($p.schema().getName()) ? ${this.mangle($p.name())} : ${this.mangle($name)}.${this.mangle($p.name())};
#end
#if($message.getRequest().getFields().size() == 1 && $response.getType().equals($message.getRequest().getFields()[0].schema().getType()))
                            ${this.mangle($name)}._result = $message.getRequest().getFields()[0].name();
#end
                                }else {
                                    seen = true;
                                }
                            return new Object[]{##
#foreach ($p in $message.getRequest().getFields())##
${this.mangle($p.name())}#if($foreach.hasNext),#end##
#end
            };

                        }catch (Exception e){
                                logger.error("fail waitTo ",e);
                        }
                        return new Object[]{};
                    }
                };
                lockForResult.await(timeOutInMin, TimeUnit.MINUTES);
                if(lock.getCount() > 0){
                     logger.error("timeOut for lock ");
                }
            }catch (Exception e){
               logger.error("fail waitTo ",e);
            }
        }
        logger.debug("successfully wait to ${this.mangle($name)}");
        return ${this.unCapitalizeFirstLetter(${this.mangle($name)})};
    }

#if (${this.javaUnbox($response, true)} != "void" )
#if($message.getRequest().getFields().size() > 1 || ($message.getRequest().getFields().size() == 1 && !$response.getType().equals($message.getRequest().getFields()[0].schema().getType())))
    public static void waitToResult(Handler<AsyncResult<${this.mangle($name)}>> resultHandler){
    if(${this.unCapitalizeFirstLetter(${this.mangle($name)})} == null){
            try{
                logger.debug("waiting for result of ${this.mangle($name)}");
                ${this.unCapitalizeFirstLetter(${this.mangle($name)})} = new ${this.mangle($name)}();
                lockForResult = new CountDownLatch(1);
                new ListenerServiceImpl(){
                @Override
                public void ${this.mangle($name)}(${this.javaUnbox($response, true)} result){
                try{
                   logger.debug("done waiting for ${this.mangle($name)}");
                   lockForResult.countDown();
                   ${this.mangle($name)}._result = result;

                }catch (Exception e){
                     logger.error("fail waitToResult ",e);
                }
         }
    };
                lockForResult.await(timeOutInMin, TimeUnit.MINUTES);
                if(lock.getCount() > 0){
                   logger.error("timeOut for lock ");
                }
                logger.debug("successfully wait to ${this.mangle($name)}");
                resultHandler.handle(Future.handleResult(${this.unCapitalizeFirstLetter(${this.mangle($name)})}));
            }catch (Exception e){
               logger.error("fail waitTo ",e);
               resultHandler.handle(Future.handleError(e));
            }
        }

    }
#end



    public ${this.javaUnbox($response, true)} get_Result(){
        return _result;
    }

    public ${this.mangle($name)} get_Result(Handler<AsyncResult<$this.javaType($response,false)>> resultHandler){
        try{
            resultHandler.handle(Future.handleResult(_result));
        }catch (Exception e){
          logger.error("fail  get_Result ",e);
          resultHandler.handle(Future.handleError(e));
        }
        logger.debug("successfully get_Result "+ _result);
        return this;
    }

    public ${this.mangle($name)} get_Result(CallFuture<$this.javaType($response,false)> future){
         future.handleResult(_result);
         return this;
    }


#end


#foreach ($p in $message.getRequest().getFields())##
    public ${this.javaUnbox($p.schema(), false)} get${this.capitalizeFirstLetter(${this.mangle($p.name())})}(){
        return ${this.mangle($name)}.${this.mangle($p.name())};
    }

    public ${this.mangle($name)} get${this.capitalizeFirstLetter(${this.mangle($p.name())})}(Handler<AsyncResult<$this.javaType($p.schema(),false)>> resultHandler){
        resultHandler.handle(Future.handleResult(${this.mangle($name)}.${this.mangle($p.name())}));
        return this;
    }

    public ${this.mangle($name)} get${this.capitalizeFirstLetter(${this.mangle($p.name())})}(CallFuture<$this.javaType($p.schema(), false)> future){
       future.handleResult(${this.mangle($name)}.${this.mangle($p.name())});
       return this;
    }

    public ${this.unCapitalizeFirstLetter(${this.mangle($name)})} set${this.capitalizeFirstLetter(${this.mangle($p.name())})}(${this.javaUnbox($p.schema(), false)} ${this.mangle($p.name())}){
        ${this.mangle($name)}.${this.mangle($p.name())} = ${this.mangle($p.name())};
        return this;
    }

#end




}

#end## (requests)
}## End of protocol interface
