#if ($protocol.getNamespace())
package $this.mangle($protocol.getNamespace());
#end
import java.util.function.Function;
import org.apache.logging.log4j.Level;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import io.cucumber.java.en.Given;
import com.fasterxml.jackson.databind.ObjectMapper;
import io.cucumber.java.ParameterType;
import org.softauto.serializer.CallFuture;
import org.softauto.core.Utils;
import java.lang.reflect.Field;
import org.springframework.expression.Expression;
import org.springframework.expression.ExpressionParser;
import org.springframework.expression.spel.standard.SpelExpressionParser;
import org.springframework.expression.spel.support.StandardEvaluationContext;
import java.util.List;
import java.util.ArrayList;
import java.util.Collection;
import java.util.concurrent.ExecutionException;
import io.cucumber.java.en.When;
import io.cucumber.java.en.Then;
import org.testng.Assert;
import io.cucumber.datatable.DataTable;
import java.util.Map;
import java.util.*;
import org.softauto.cucumber.*;

#if ($protocol.getDoc())
/** $protocol.getDoc() */
#end
#foreach ($annotation in $this.javaAnnotations($protocol))
@$annotation
#end
@org.apache.avro.specific.AvroGenerated
public class $this.mangle($protocol.getName())CucumberImpl extends CucumberAbstractTesterImpl {
#if($protocol.getMessages().size() > 0)
    private static org.apache.logging.log4j.Logger logger = org.apache.logging.log4j.LogManager.getLogger($this.mangle($protocol.getName())CucumberImpl.class);

    public $this.mangle($protocol.getName())CucumberImpl(){
        registerGlueClass(this);
    }




#set ($exp = $cucumberutils.getVarName("exp"))
#set ($future = $cucumberutils.getVarName("future"))


@ParameterType(".*")
public String $exp (String $exp) throws Exception{
    return $exp;
}



@Then("local step result of {$exp}")
public void validate(String $exp )throws Exception{
   String left = CucumberUtils.getLeft($exp);
       String right = CucumberUtils.getRight($exp);
       String operator = CucumberUtils.getOperator($exp);
       boolean result = getResult(CucumberUtils.expToGetter(left) +" "+ operator +" "+ CucumberUtils.expToGetter(right));
       Assert.assertTrue(result);
}




#foreach ($e in $protocol.getMessages().entrySet())
#set ($name = $e.getKey())
#set ($message = $e.getValue())
#set ($response = $message.getResponse())
#set ($class = $message.getJsonProp("class"))
#set ($fullClassName = $class.get("fullClassName").asText())
#set ($responseVarName = $cucumberutils.getVarName(${this.javaUnbox($response, true)}))

#foreach ($p in $message.getRequest().getFields())##
#set ($varName = $cucumberutils.getVarName($p.name()))
$p.setName($varName)
$cucumberutils.addVarName($varName)

## for every argument create parameterType if not exist
#if(!$cucumberutils.hasParameterType($varName))
@ParameterType(".*")
public ${this.javaUnbox($p.schema(),false)} $varName (String $varName)throws Exception{
if(Utils.isJson($varName)){
      return new ObjectMapper().readValue($varName, ${this.getOwnerTypeName(${this.javaUnbox($p.schema(),false)})}.class);
}
      ExpressionParser parser = new SpelExpressionParser();
      StandardEvaluationContext itemContext = getContext($varName);
      if(itemContext == null){
          itemContext = new StandardEvaluationContext(this);
       }
      Expression exp2 = parser.parseExpression($varName);
      ${this.javaUnbox($p.schema(),false)} result = (${this.javaUnbox($p.schema(),false)}) exp2.getValue(itemContext,${this.getOwnerTypeName(${this.javaUnbox($p.schema(),false)})}.class);

return result;
}
#end
$cucumberutils.addParameterType(${this.javaUnbox($p.schema(),false)}, $varName)
#end ## end of create parameterType

#if (${this.javaUnbox($response, true)} != "void" )
public ${this.javaUnbox($response, true)} $responseVarName;
#end
#if($message.hasWhenDescription())
@When("$message.getWhenDescription()")
#else
@When("$cucumberutils.getDefaultWhenDescription(${this.mangle($name)})##
#foreach ($p in $message.getRequest().getFields())##
$cucumberutils.getbeforeFieldName($p.schema().getType(),$p.name()) {$p.name()}#if($foreach.hasNext) and #end
#end##
")
#end
#if($message.hasGivenDescription())
@Given("$message.getGivenDescription()")
#else
@Given("$cucumberutils.getDefaultGivenDescription(${this.mangle($name)})##
#foreach ($p in $message.getRequest().getFields())##
$cucumberutils.getbeforeFieldName($p.schema().getType(),$p.name()) {$p.name()}#if($foreach.hasNext) and #end
#end##
")
#end
public ${this.javaUnbox($response, true)} ${this.mangle($name)}(##
#foreach ($p in $message.getRequest().getFields())##
#*      *#${this.javaUnbox($p.schema(), false)} $p.name()#if ($foreach.hasNext), #end
#end
){
#if (${this.javaUnbox($response, true)} != "void" )
    $responseVarName = ##
#end
localTests.${this.mangle($name)}(##
#foreach ($p in $message.getRequest().getFields())##
#*      *#${this.mangle($p.name())}#if ($foreach.hasNext), #end
#end
);
#if (${this.javaUnbox($response, true)} != "void" )
    return $responseVarName;
#end
}
#if (${this.javaUnbox($response, true)} != "void" )
#if($message.hasThenDescription())
@Given("$message.getThenDescription()")
#else
@Then("$cucumberutils.getDefaultThenDescription(${this.mangle($name)}) {exp}")
public void validate_$cucumberutils.getMethodName(${this.mangle($name)})(String $exp )throws Exception{
    String left = CucumberUtils.getLeft($exp);
    String right = CucumberUtils.getRight($exp);
    String operator = CucumberUtils.getOperator($exp);
    boolean result = getResult(CucumberUtils.expToGetter($responseVarName+" "+left) +" "+ operator +" "+ CucumberUtils.expToGetter(right));
    Assert.assertTrue(result);
}
#end
#end


#if ($message.getRequest().getFields().size() > 0)
#foreach ($p in $message.getRequest().getFields())##
#set ($objectVarName = $cucumberutils.getVarName(${this.getBasicTypeName("${p.name()}List")}))
#if(!$cucumberutils.isPrimitive(${this.javaUnbox($p.schema(), false)}))
#if(!$cucumberutils.hasObjectName(${this.getBasicTypeName(${this.javaUnbox($p.schema(), false)})}))
$cucumberutils.addObjectName(${this.getBasicTypeName(${this.javaUnbox($p.schema(), false)})},$objectVarName)
public List<${this.getBasicTypeName(${this.javaUnbox($p.schema(), false)})}> $objectVarName;
     @When("got list of $cucumberutils.getShortVarName(${this.javaUnbox($p.schema(), false)})")
     @Given("list of $cucumberutils.getShortVarName(${this.javaUnbox($p.schema(), false)})")
     public List<${this.getBasicTypeName(${this.javaUnbox($p.schema(), false)})}> create_$cucumberutils.fqmnToString(${this.javaUnbox($p.schema(), false)}) (DataTable table){
     try{
        List<Map<String, String>> map = table.asMaps(String.class, String.class);
        String json = new ObjectMapper().writeValueAsString(map);
        ${this.getBasicTypeName(${this.javaUnbox($p.schema(), false)})}[] res = new ObjectMapper().readValue(json, ${this.getBasicTypeName(${this.javaUnbox($p.schema(), false)})}[].class);
        $objectVarName = Arrays.asList(res);
     }catch (Exception e){
        e.printStackTrace();
     }
     return   $objectVarName;
     }

#end
#end
#if($foreach.hasNext)#end
#end##
#end

#set ($varNameFuture = $cucumberutils.getVarName("future"))
@ParameterType(".*")
public CallFuture $varNameFuture (String $varNameFuture)throws Exception{
   return new CallFuture<$message.getResponseTypeForCallBack()>();
}
#set ($typeVarName = $cucumberutils.getVarName(${this.javaUnbox($response, true)}))
#if (${this.javaUnbox($response, true)} != "void" )
$message.getResponseTypeForCallBack() $typeVarName;
#end

#foreach ($p in $message.getRequest().getFields())##
#set ($varName = $cucumberutils.getVarName($p.name()))
$p.setName($varName)
$cucumberutils.addVarName($varName)
@ParameterType(".*")
public ${this.javaUnbox($p.schema(),false)} $varName (String $varName)throws Exception{
if(Utils.isJson($varName)){
      return new ObjectMapper().readValue($varName, ${this.getOwnerTypeName(${this.javaUnbox($p.schema(),false)})}.class);
}
      ExpressionParser parser = new SpelExpressionParser();
      StandardEvaluationContext itemContext = getContext($varName);
      if(itemContext == null){
          itemContext = new StandardEvaluationContext(this);
      }
      Expression exp2 = parser.parseExpression($varName);
      ${this.javaUnbox($p.schema(),false)} result = (${this.javaUnbox($p.schema(),false)}) exp2.getValue(itemContext,${this.getBasicTypeName(${this.javaUnbox($p.schema(),false)})}.class);

return result;
}
//public ${this.javaUnbox($p.schema(),false)} $varName;
#if($foreach.hasNext)#end
#end

#set ($resultVarName = $cucumberutils.getVarName(${this.mangle($name)}))
CallFuture<$message.getResponseTypeForCallBack()> $varNameFuture;
$message.getResponseTypeForCallBack() async_${resultVarName}_result;


public $message.getResponseTypeForCallBack() get${this.capitalizeFirstLetter($varNameFuture)}() throws ExecutionException, InterruptedException{
        async_${resultVarName}_result =  ${varNameFuture}.get();
        return async_${resultVarName}_result;
}

#if($message.hasWhenDescription())
@When("$message.getWhenDescription()")
#else
@When("$cucumberutils.getDefaultWhenDescription(${this.mangle($name)})##
#foreach ($p in $message.getRequest().getFields())##
$cucumberutils.getbeforeFieldName($p.schema().getType(),$p.name()) {$p.name()}#if($foreach.hasNext) and #end
#end##
 #async")
#end
#if($message.hasGivenDescription())
@Given("$message.getGivenDescription()")
#else
@Given("$cucumberutils.getDefaultGivenDescription(${this.mangle($name)})##
#foreach ($p in $message.getRequest().getFields())##
$cucumberutils.getbeforeFieldName($p.schema().getType(),$p.name()) {$p.name()}#if($foreach.hasNext) and #end
#end##
 #async")
#end
public ##
void async_${this.mangle($name)}(##
#foreach ($p in $message.getRequest().getFields())##
#*      *#${this.javaUnbox($p.schema(), false)} $p.name()#if ($foreach.hasNext), #end
#end
)throws Exception ##
{
$varNameFuture = new CallFuture<>();
#*      *#localAsyncTests.${this.mangle($name)}(##
#foreach ($p in $message.getRequest().getFields())##
#*      *#${this.mangle($p.name())}#if ($foreach.hasNext), #end
#end
#if($message.getRequest().getFields().size()>0),#end $varNameFuture);
}

#end

#end
}## End of protocol interface
