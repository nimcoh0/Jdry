#if ($protocol.getNamespace())
package $this.mangle($protocol.getNamespace());
#end
import java.util.function.Function;
import org.apache.logging.log4j.Level;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import io.cucumber.java.en.When;
import com.fasterxml.jackson.databind.ObjectMapper;
import io.cucumber.java.ParameterType;
import org.softauto.core.CallFuture;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.lang.reflect.Field;
import org.softauto.core.Utils;
import org.springframework.expression.Expression;
import org.springframework.expression.ExpressionParser;
import org.springframework.expression.spel.standard.SpelExpressionParser;
import org.springframework.expression.spel.support.StandardEvaluationContext;

#if ($protocol.getDoc())
/** $protocol.getDoc() */
#end
#foreach ($annotation in $this.javaAnnotations($protocol))
@$annotation
#end
@org.apache.avro.specific.AvroGenerated
public class $this.mangle($protocol.getName())CucumberImpl  {

    private static Logger logger = LogManager.getLogger($this.mangle($protocol.getName())CucumberImpl.class);

    public $this.mangle($protocol.getName())CucumberImpl(){
          try {
             if( Class.forName("org.softauto.listener.ListenerObserver", false, this.getClass().getClassLoader())!= null){
                 org.softauto.listener.ListenerObserver.getInstance().register("tests.infrastructure.ListenerServiceCucumberImpl", this);
             }
         }catch (Exception e){
           // e.printStackTrace();
         }
    }

#foreach ($e in $protocol.getMessages().entrySet())
#set ($name = $e.getKey())
#set ($message = $e.getValue())
#set ($response = $message.getResponse())
  /**
#if ($message.getDoc())
   * $this.escapeForJavadoc($message.getDoc())
#end
#foreach ($p in $message.getRequest().getFields())##
#if ($p.doc())   * @param ${this.mangle($p.name())} $p.doc()
#end
#end
   */
#foreach ($annotation in $this.javaAnnotations($message))
  @$annotation
#end
#if(!$name.contains("_result"))
#foreach ($p in $message.getRequest().getFields())##
#set ($varName = $cucumber.getVarName($p.name()))
$p.setName($varName)
@ParameterType(".*")
public ${this.javaUnbox($p.schema(),false)} $varName (String $varName)throws Exception{
if(Utils.isJson($varName)){
      return new ObjectMapper().readValue($varName, ${this.getBasicTypeName(${this.javaUnbox($p.schema(),false)})}.class);
}
      ExpressionParser parser = new SpelExpressionParser();
      StandardEvaluationContext itemContext = new StandardEvaluationContext(this);
      Expression exp2 = parser.parseExpression($varName);
      ${this.javaUnbox($p.schema(),false)} result = (${this.javaUnbox($p.schema(),false)}) exp2.getValue(itemContext,${this.getBasicTypeName(${this.javaUnbox($p.schema(),false)})}.class);

return result;
  }

public ${this.javaUnbox($p.schema(),false)} $varName;

#if($foreach.hasNext)#end
#end
#else
#foreach ($p in $message.getRequest().getFields())##
      ${this.javaUnbox($p.schema(), false)}  ${this.mangle($name)}_$p.name()  ;
#end ##
#end
@When("${this.mangle($name)}##
#if(!$name.contains("_result"))
#foreach ($p in $message.getRequest().getFields())##
{$p.name()}#if($foreach.hasNext),#end
#end##
#end
")
public ##
#foreach ($p in $message.getRequest().getFields())##
#if($p.schema().isGeneric())<${this.javaUnbox($p.schema(),false)}>#end#if($foreach.hasNext)#end ##
#end
java.lang.Object[] ${this.mangle($name)}(##
#if(!$name.contains("_result"))
#foreach ($p in $message.getRequest().getFields())##
#*      *#${this.javaUnbox($p.schema(), false)} $p.name()#if ($foreach.hasNext), #end
#end
#end
)#if (! $message.isOneWay() && $message.getErrors().getTypes().size() > 1)
 throws ##
## The first error is always "string", so we skip it.
#foreach ($error in $message.getErrors().getTypes().subList(1, $message.getErrors().getTypes().size()))
${this.mangle($error.getFullName())}##
#if ($foreach.hasNext), #end
#end##    (error list)
#end##    (one way)
{
AtomicReference<Object[]> ref = new AtomicReference();
try {
    CountDownLatch lock = new CountDownLatch(1);
    new ListenerServiceImpl() {
        @Override
        public ${this.javaUnbox($response, true)} ${this.mangle($name)}(##
#foreach ($p in $message.getRequest().getFields())##
${this.javaUnbox($p.schema(), false)} new$p.name()#if ($foreach.hasNext), #end
#end ##
) {
#if (${this.javaUnbox($response, true)} != "void" )
        lock.countDown();
        return new Object[]{##
#foreach ($p in $message.getRequest().getFields())##
$p.name()#if ($foreach.hasNext), #end
#end ##
};
         };
#else
#foreach ($p in $message.getRequest().getFields())##
        ${this.mangle($name)}_$p.name()  = new$p.name() ;
#end##
        ref.set(new Object[]{##
#foreach ($p in $message.getRequest().getFields())##
new$p.name()#if ($foreach.hasNext), #end
#end ##
});
        lock.countDown();
        }
#end
     };
    lock.await(10, TimeUnit.MINUTES);
}catch (Exception e){
   e.printStackTrace();
}
return ref.get();
}



#end## (requests)
}## End of protocol interface
