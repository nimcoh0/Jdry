#if ($protocol.getNamespace())
package $this.mangle($protocol.getNamespace());
#end
import java.util.function.Function;
import org.apache.logging.log4j.Level;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import io.cucumber.java.en.Given;
import com.fasterxml.jackson.databind.ObjectMapper;
import io.cucumber.java.ParameterType;
import org.softauto.core.CallFuture;
import org.softauto.core.Utils;
import java.lang.reflect.Field;
import org.springframework.expression.Expression;
import org.springframework.expression.ExpressionParser;
import org.springframework.expression.spel.standard.SpelExpressionParser;
import org.springframework.expression.spel.support.StandardEvaluationContext;
import java.util.List;
import java.util.ArrayList;
import java.util.Collection;
import java.util.concurrent.ExecutionException;
import io.cucumber.java.en.When;
import io.cucumber.java.en.Then;
import org.testng.Assert;


#if ($protocol.getDoc())
/** $protocol.getDoc() */
#end
#foreach ($annotation in $this.javaAnnotations($protocol))
@$annotation
#end
@org.apache.avro.specific.AvroGenerated
public class $this.mangle($protocol.getName())CucumberImpl extends CucumberAbstractTester {

    private static Logger logger = LogManager.getLogger($this.mangle($protocol.getName())CucumberImpl.class);


    public boolean getResult (String result){
         ExpressionParser parser = new SpelExpressionParser();
         StandardEvaluationContext itemContext = new StandardEvaluationContext(this);
         Expression exp2 = parser.parseExpression(result);
         boolean res = (java.lang.Boolean) exp2.getValue(itemContext,Boolean.class);
         return res;
    }


    public Object evulExp(String exp){
        ExpressionParser parser = new SpelExpressionParser();
        StandardEvaluationContext itemContext = new StandardEvaluationContext(this);
        Expression exp2 = parser.parseExpression(exp);
        return exp2.getValue(itemContext);
    }

#set ($exp = $cucumber.getVarName("exp"))
#set ($future = $cucumber.getVarName("future"))

@ParameterType(".*")
public String $exp (String $exp) throws Exception{
    return $exp;
}


@ParameterType(".*")
public Object $future (String $future) throws Exception{
      ExpressionParser parser = new SpelExpressionParser();
      StandardEvaluationContext itemContext = new StandardEvaluationContext(this);
      Expression exp2 = parser.parseExpression("get"+future.toUpperCase().charAt(0)+future.substring(1,future.length())+"()");
      return exp2.getValue(itemContext);
}



@Then("validate result of {$exp}")
public void validate(String $exp){
    boolean result = getResult($exp);
    Assert.assertTrue(result);
}

@Then("validate result of {$exp} {$future} #async")
public void asyncValidate (String $exp ,Object $future) throws ExecutionException, InterruptedException{
    boolean result = getResult($exp);
    Assert.assertTrue(result);
}


#foreach ($e in $protocol.getMessages().entrySet())
#set ($name = $e.getKey())
#set ($message = $e.getValue())
#set ($response = $message.getResponse())
#set ($typeVarName = $cucumber.getVarName(${this.javaUnbox($response, true)}))
  /**
#if ($message.getDoc())
   * $this.escapeForJavadoc($message.getDoc())
#end
#foreach ($p in $message.getRequest().getFields())##
#if ($p.doc())   * @param ${this.mangle($p.name())} $p.doc()
#end
#end
   */
#foreach ($annotation in $this.javaAnnotations($message))
  @$annotation
#end
#foreach ($p in $message.getRequest().getFields())##
#set ($varName = $cucumber.getVarName($p.name()))
$p.setName($varName)
$cucumber.addVarName($varName)
@ParameterType(".*")
public ${this.javaUnbox($p.schema(),false)} $varName (String $varName)throws Exception{
if(Utils.isJson($varName)){
      return new ObjectMapper().readValue($varName, ${this.getBasicTypeName(${this.javaUnbox($p.schema(),false)})}.class);
}
      ExpressionParser parser = new SpelExpressionParser();
      StandardEvaluationContext itemContext = new StandardEvaluationContext(this);
      Expression exp2 = parser.parseExpression($varName);
      ${this.javaUnbox($p.schema(),false)} result = (${this.javaUnbox($p.schema(),false)}) exp2.getValue(itemContext,${this.getBasicTypeName(${this.javaUnbox($p.schema(),false)})}.class);

return result;
}
public ${this.javaUnbox($p.schema(),false)} $varName;
#if($foreach.hasNext)#end
#end

#if (${this.javaUnbox($response, true)} != "void" )
public ${this.javaUnbox($response, true)} $typeVarName;
#end
#if($message.hasDescription())
@Given("$cucumber.buildDescription($message.getDescription())##
#else
@Given("$cucumber.getVarName(${this.mangle($name)}) ##
#foreach ($p in $message.getRequest().getFields())##
 with $p.name() {$p.name()}#if($foreach.hasNext) and #end
#end##
#end
")
public ##
#foreach ($p in $message.getRequest().getFields())##
#if($p.schema().isGeneric())<${this.javaUnbox($p.schema(),false)}>#end#if($foreach.hasNext)#end ##
#end
${this.javaUnbox($response, true)} ${this.mangle($name)}(##
#foreach ($p in $message.getRequest().getFields())##
#*      *#${this.javaUnbox($p.schema(), false)} $p.name()#if ($foreach.hasNext), #end
#end
)#if (! $message.isOneWay() && $message.getErrors().getTypes().size() > 1)
 throws ##
## The first error is always "string", so we skip it.
#foreach ($error in $message.getErrors().getTypes().subList(1, $message.getErrors().getTypes().size()))
${this.mangle($error.getFullName())}##
#if ($foreach.hasNext), #end
#end##    (error list)
#end##    (one way)
{
#if (${this.javaUnbox($response, true)} != "void" )
    $typeVarName = ##
#end
tests.${this.mangle($name)}(##
#foreach ($p in $message.getRequest().getFields())##
#*      *#${this.mangle($p.name())}#if ($foreach.hasNext), #end
#end
);
#if (${this.javaUnbox($response, true)} != "void" )
    return $typeVarName;
#end
}
#set ($varNameFuture = $cucumber.getVarName("future"))
@ParameterType(".*")
public CallFuture $varNameFuture (String $varNameFuture)throws Exception{
   return new CallFuture<$message.getResponseTypeForCallBack()>();
}
#set ($typeVarName = $cucumber.getVarName(${this.javaUnbox($response, true)}))
#if (${this.javaUnbox($response, true)} != "void" )
$message.getResponseTypeForCallBack() $typeVarName;
#end

#foreach ($p in $message.getRequest().getFields())##
#set ($varName = $cucumber.getVarName($p.name()))
$p.setName($varName)
$cucumber.addVarName($varName)
@ParameterType(".*")
public ${this.javaUnbox($p.schema(),false)} $varName (String $varName)throws Exception{
if(Utils.isJson($varName)){
      return new ObjectMapper().readValue($varName, ${this.getBasicTypeName(${this.javaUnbox($p.schema(),false)})}.class);
}
      ExpressionParser parser = new SpelExpressionParser();
      StandardEvaluationContext itemContext = new StandardEvaluationContext(this);
      Expression exp2 = parser.parseExpression($varName);
      ${this.javaUnbox($p.schema(),false)} result = (${this.javaUnbox($p.schema(),false)}) exp2.getValue(itemContext,${this.getBasicTypeName(${this.javaUnbox($p.schema(),false)})}.class);

return result;
}
public ${this.javaUnbox($p.schema(),false)} $varName;
#if($foreach.hasNext)#end
#end

#set ($resultVarName = $cucumber.getVarName(${this.mangle($name)}))
CallFuture<$message.getResponseTypeForCallBack()> $varNameFuture;
$message.getResponseTypeForCallBack() async_${resultVarName}_result;


public $message.getResponseTypeForCallBack() get${this.capitalizeFirstLetter($varNameFuture)}() throws ExecutionException, InterruptedException{
        async_${resultVarName}_result =  ${varNameFuture}.get();
        return async_${resultVarName}_result;
}

#if($message.hasDescription())
@Given("$cucumber.buildDescription($message.getDescription())##
#else
@Given("$cucumber.getVarName(${this.mangle($name)}) ##
#foreach ($p in $message.getRequest().getFields())##
with $p.name() {$p.name()}#if($foreach.hasNext) and #end
#end##
#end
 #async")
public ##
#foreach ($p in $message.getRequest().getFields())##
#if($p.schema().isGeneric())<${this.javaUnbox($p.schema(),false)}>#end#if($foreach.hasNext)#end ##
#end
void async_${this.mangle($name)}(##
#foreach ($p in $message.getRequest().getFields())##
#*      *#${this.javaUnbox($p.schema(), false)} $p.name()#if ($foreach.hasNext), #end
#end
)throws Exception #if (! $message.isOneWay() && $message.getErrors().getTypes().size() > 1)
 throws ##
## The first error is always "string", so we skip it.
#foreach ($error in $message.getErrors().getTypes().subList(1, $message.getErrors().getTypes().size()))
${this.mangle($error.getFullName())}##
#if ($foreach.hasNext), #end
#end##    (error list)
#end##    (one way)
{
$varNameFuture = new CallFuture<>();
#*      *#asyncTests.${this.mangle($name)}(##
#foreach ($p in $message.getRequest().getFields())##
#*      *#${this.mangle($p.name())}#if ($foreach.hasNext), #end
#end
#if($message.getRequest().getFields().size()>0),#end $varNameFuture);
}

#end## (requests)
}## End of protocol interface
